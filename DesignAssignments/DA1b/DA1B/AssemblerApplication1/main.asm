;
; AssemblerApplication1.asm
;
; Created: 9/21/2019 7:09:45 PM
; Author : Dilbert
;
.include <m328pbdef.inc>
	;DEFINING GLOBAL CONSTANTS;
	.EQU DIVIS			= 0x05		;WHAT IS BEING DIVIDED BY	
	.EQU QUANTITY		= 0xFA		;HOW MANY ARE BEING CREATED
	.EQU MAXQUANT		= 0xFF		;MAX VALUE POSSIBLE

	.SET STARTADDS		= 0x0200	;MEMORY ADDRESS FOR INITIAL FILL
	.SET DIVISABLE		= 0x0300	;MEMORY ADDRESS FOR VALUES DIVISIBLE BY FIVE
	.SET NONDIVISABLE	= 0x0500	;MEMORY ADDRESS FOR VALUES NOT DIVISIBLE BY FIVE

;THIS MACRO WILL CHECK FOR DIVISIBILITY BY FIVE, AND ONLY FIVE.
.MACRO IS_DIVIS						;MACRO FOR DETERIMINING IF A VALUE IS DIVISABLE BY FIVE
DIVISABATOR:						;START OF LOOP
	SUBI @0,5						;SUBTRACT 5 FROM THE DIVIDEND
	BREQ CHICKEN_DINNER				;IF THAT BRINGS THE DIVIDEND TO ZERO, YOU HAVE A WINNER, GO TO CHICKEN DINNER
	MOV R16,@0						;COPY THE VALUE IN THE PROVIDED REGISTER TO R16
	SUBI R16,4						;SUBTRACT 4 FROM THE DIVIDEND IN R16
	BREQ JIM_CARRY					;IF EQUAL TO ZERO, IT'S A LOOSAHER (LOSER) BREAK TO JIM_CARRY
	MOV R16,@0						;COPY THE VALUE IN THE PROVIDED REGISTER TO R16 AGAIN (RESET)
	SUBI R16,3						;SUBTRACT 3 FROM THE DIVIDEND IN R16
	BREQ JIM_CARRY					;IF EQUAL TO ZERO, IT'S A LOOSAHER (LOSER) BREAK TO JIM_CARRY
	MOV R16,@0						;COPY THE VALUE IN THE PROVIDED REGISTER TO R16 AGAIN (RESET)
	SUBI R16,2						;SUBTRACT 2 FROM THE DIVIDEND IN R16
	BREQ JIM_CARRY					;IF EQUAL TO ZERO, IT'S A LOOSAHER (LOSER) BREAK TO JIM_CARRY
	MOV R16,@0						;COPY THE VALUE IN THE PROVIDED REGISTER TO R16 AGAIN (RESET)
	SUBI R16,1						;SUBTRACT 1 FROM THE DIVIDEND IN R16
	BREQ JIM_CARRY					;IF EQUAL TO ZERO, IT'S A LOOSAHER (LOSER) BREAK TO JIM_CARRY
	RJMP DIVISABATOR				;IF FAILD ALL THESE CHECKS, JUMP BACK UP TO TOP OF LOOP
JIM_CARRY:							;WHERE NON-DIVISABLE BY FIVE NUMBERS GO
	LDI R16, 0x00					;LOAD ZERO INTO R16 (ACTS AS A BOOLEAN FALSE)
	RJMP ENDERMAKER					;JUMP TO THE END OF MACRO
CHICKEN_DINNER:						;WHERE NUMBERS THAT ARE DIVISABLE BY FIVE GO
	LDI R16, 0x01					;LOAD ONE INTO R16 (ACTS AS A BOOLEAN TRUE)
ENDERMAKER:							;END LABEL TO BE JUMPED TO BY JIM-CARRY
	.ENDMACRO

;************ MAIN PROG BEGIN *******************
	LDI XL, LOW(STARTADDS)			;LOADING THE STARTADDS MEMORY ADDRESS INTO THE LOW SIDE OF X REGISTER
	LDI XH, HIGH(STARTADDS)			;LOADING THE STARTADDS MEMORY ADDRESS INTO THE HIGH SIDE OF X REGISTER
	LDI YL, LOW(DIVISABLE)			;LOADING THE DIVISABLE MEMORY ADDRESS INTO THE LOW SIDE OF Y REGISTER
	LDI YH, HIGH(DIVISABLE)			;LOADING THE DIVISABLE MEMORY ADDRESS INTO THE HIGH SIDE OF Y REGISTER
	LDI ZL, LOW(NONDIVISABLE)		;LOADING THE NONDIVISABLE MEMORY ADDRESS INTO THE LOW SIDE OF THE Z REGISTER
	LDI ZH, HIGH(NONDIVISABLE)		;LOADING THE NONDIVISABLE MEMORY ADDRESS INTO THE HIGH SIDE OF THE Z REGISTER
	LDI R25, DIVIS					;LOADING THE DIVIS VALUE (0x05) INTO R25
	CALL FILL_VALS					;CALLING THE FUNCTION FILL_VALS
POST:								;LABEL POST: RETURN POINT OF BADDLY_DIVIS AND GOODLY_DIVIS
	LD R24,X+						;LOAD THE VALUE STORED AT LOCATION POINTED TO BY X, INTO REGISTER R24, THE INCREMENT POINTER VALUE
	CPI R24, 0x00					;COMPARE THIS VALUE TO ZERO IN ORDER TO DETERMIN IF THE END OF THE SET HAS BEEN REACHED
	BREQ NEXT						;IF (R24 == 0) BRANCH TO THE LOCATION "NEXT;" MEANING THE ORGINIZATION PHAZE IS OVER
	MOV R23,R24						;COPY R24 INTO R23 IN ORDER TO PRESERVE THE VALUE HELD BY R24 WHEN CALLING IS_DIVIS MACRO
	IS_DIVIS R23					;CALLING IS_DIVIS MACRO
	CPI R16, 0x00					;COMPARE R16 (BOOLEAN 0/1) WITH ZERO
	BREQ BADDLY_DIVIS				;BRANCH IF R16 RETURNS AS ZERO (VALUE IN R24 IS NOT DIVISABLE BY 5)
	BRNE GOODLY_DIVIS				;BRANCH IF R16 RETURNS AS ONE (VALUE IN R24 IS DIVISBALE BY 5)
	JMP ERROR						;THIS INSTRUCTION SHOULD NEVER BE REACHED, IF REACHED THERE IS AN ERROR
									;	JMP ERROR IS ACTING AS A "DEFAULT CASE STATMENT"

;COMPARISONS ARE COMPLETE, NOW TO DO PORTION 3 OF DA1B 
;(UNSURE OF WHAT THE INSTRUCTIONS WERE ASKING FOR SO THIS IS MY INTERPRITATION OF THE INSTRUCTIONS)
NEXT:								
	SUB R17,R17						;ENSURE R17 IS ZERO
	SUB R19,R19						;ENSURE R19 IS ZERO
	SUB R20,R20						;ENSURE R20 IS ZERO
	LDI YL, LOW(DIVISABLE)			;RELOAD REG YLOW WITH LOW OF DIVISABLE (STARTING LOCATION OF THE DIVISABLE DATA)
	LDI YH, HIGH(DIVISABLE)			;RELOAD REG YHIGH WITH HIGH OF DIVISABLE (STARTING LOCATION OF THE DIVISABLE DATA)
	LDI ZL, LOW(NONDIVISABLE)		;RELOAD REG ZLOW WITH LOW OF NONDIVISABLE (STARTING LOCATION OF THE NONDIVISABLE DATA)
	LDI ZH, HIGH(NONDIVISABLE)		;RELOAD REG ZHIGH WITH HIGH OF NONDIVISABLE (STARTING LOCATION OF THE NONDIVISABLE DATA)
	LD R16,Z+						;LOAD THE VALUE POINTED TO BY Z INTO R16, AND THEN INCREMENT THE POINTER VALUE
	LD R22,Y+						;LOAD THE VALUE POINTED TO BY Y INTO R22, AND THEN INCREMENT THE POINTER VALUE
	ADD R16,R22						;ADD R16 AND R22 VALUES AND STORE THEM INTO R16
	ADC R17,R20						;ADD R17(ZERO) WITH R20(ALSO ZERO) AND THE CARRY, STORE INTO R17
	LD R18,Z						;LOAD THE VALUE POINTED TO BY Z INTO R18
	LD R22,Y						;LOAD THE VALUE POINTED TO BY Y INTO R22
	ADD R18,R22						;ADD R18 AND R22 VALUES AND STORE THEM INTO R18
	ADC R19,R20						;ADD R19(ZERO) WITH R20(ALSO ZERO) AND THE CARRY, STORE INTO R19
DONE:
	JMP DONE						;LOOP DONE

ERROR:								;ERROR STATE SHOULD NEVER BE REACHED, IF IT IS IT WILL STAY IN INFINATE LOOP FORCING REBOOT?
	JMP ERROR

BADDLY_DIVIS:						;IF THE RESULT OF IS_DIVIS IS 0, THEN R24 IS NOT DIVISABLE BY FIVE, PROGRAM JUMPS HERE
	ST Z+,R24						;STORE THE VALUE IN R24 IN THE MEMORY LOCATION POINTED TO BY Z, THEN INCREMENT Z
	RJMP POST						;JUMP BACK TO THE MAIN PROGRAM AT POST:

GOODLY_DIVIS:						;IF THE RESULT OF IS_DIVIS IS 1, THEN R24 IS DIVISABLE BY FIVE, PROGRAM JUMPS HERE
	ST Y+,R24						;STORE THE VALUE IN R24 IN THE MEMORY LOCATION POINTED TO BY Y, THEN INCREMENT Y
	RJMP POST						;JUMP BACK TO THE MAIN PROGRAM AT POST

FILL_VALS:							;FILL THE MEMORY WITH DATA
	LDI R16, MAXQUANT				;THIS STARTS AS THE MAXIMUM NUMBER THAT A VALUE CAN BE, AND IS THEN DECREMENTED UNTIL THE QUANTITY IS ZERO
	LDI R18, QUANTITY				;THIS IS HOW MANY NUMBERS ARE LEFT TO BE GENERATED
LOOP:
	ST X+,R16						;STORE THE VALUE IN R16 TO THE MEMORY LOCATION POINTED TO BY X, THEN INCREMENT THE POINTER VALUE
	DEC R16							;DECREMENT THE VALUE STORED IN R16
	DEC R18							;DECREMENT THE VALUE STORED IN R18
	BRNE LOOP						;IF R18 IS NOT ZERO, BRANCH BACK UP TO LOOP
	LDI XL, LOW(STARTADDS)			;RESTORE THE POINTER VALUE OF REG X TO BE REUSED LATER
	LDI XH, HIGH(STARTADDS)			;RESTORE THE POINTER VALUE OF REG X TO BE REUSED LATER IN PROGRAM
	RET


	;******** UNUSED BUT KEPT FOR FUTURE CONSIDERATION ***********
;-----MADE IN AN ATTEMPT TO CREATE REUSABLE CODE FOR FUTURE APLICATIONS--------
;THIS MACRO WILL EMPTY ARG 0, BE SURE YOU CAN LOSE WHAT IS SENT TO ME       
;WILL CHECK IF ONE NUMBER IS DIVISABLE BY ANY OTHER NUMBER					
;RETURNS 
;SYNTAX- "IS_DIVIS REG_DIVIDEND, REG_DIVISOR"								
;.MACRO IS_DIVIS
;DIVISABATOR:
;	SUB @0, @1
;	BREQ CHICKEN_DINNER
;	BRMI JIM_CARRY
;	RJMP DIVISABATOR
;JIM_CARRY:
;	LDI R16, 0x00
;	RJMP ENDERMAKER
;CHICKEN_DINNER:
;	LDI R16, 0x01
;ENDERMAKER:
;	.ENDMACRO
;------------------------------------------------------------------------------